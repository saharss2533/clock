<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AR Day/Night Tint Overlay</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        html, body { height: 100%; width: 100%; overflow: hidden; }

        body { background: transparent; position: relative; }

        .tint-overlay {
            position: fixed;
            top: 5vh; left: 0;
            width: 100vw; height: 100vh;
            pointer-events: none;
            -webkit-user-select: none;
            user-select: none;
            touch-action: none;
            background: none;
            
            mix-blend-mode: multiply;
            opacity: 0.3;
            z-index: 1000;
        }

        /*
        .debug-info {
            position: fixed;
            top: 10px; left: 10px;
            color: white; font-family: monospace; font-size: 12px;
            background: rgba(0, 0, 0, 0.3);
            padding: 10px; border-radius: 5px;
            z-index: 1001;
        }
        */

        /* NEW: clock canvas pinned top-left, above overlay/debug */
        #clock {
            position: fixed;
            top: 10px; left: 0;
            width: 130px; height: 130px;   /* visual size */
            background: transparent;
            pointer-events: none;
            -webkit-user-select: none;
            user-select: none;
            touch-action: none;
            
            z-index: 1002;
        }
    </style>
</head>
<body>
    <div class="tint-overlay" id="tintOverlay"></div>
    <div class="debug-info" id="debugInfo"></div>
    <!-- NEW: clock canvas -->
    <canvas id="clock" width="160" height="160"></canvas>

    <script>
        // Color definitions
        let sunriseColor, middayColor, sunsetColor, nightColor;
        let totalLength = 24 * 60000; // 4 minutes = 24h simulated

        // Debug phase tracking
        let currentPhase = "";

        // Phase times (HH:MM)
        let sunriseTimeStr = "06:30";
        let middayTimeStr  = "12:00";
        let lateNoonTimeStr = "15:00";  // New Late Noon phase
        let sunsetTimeStr  = "19:00";
        let earlyNightTimeStr = "21:00";
        let nightTimeStr   = "01:30";

        // Converted to minutes
        let sunriseM, middayM, lateNoonM, sunsetM, earlyNightM, nightM;

        // Easing factors (kept as-is)
        let easeFactorSunriseMidday = 3;
        let easeFactorMiddayLateNoon = 3;
        let easeFactorLateNoonSunset  = 3;
        let easeFactorSunsetEarlyNight = 2;
        let easeFactorEarlyNightNight = 2;
        let easeFactorNightSunrise = 3;

        nightColor   = {r: 30, g: 50, b:120};
        sunriseColor = {r: 255, g: 210, b:150};
        middayColor  = {r: 255, g: 255, b:255};
        lateNoonColor = {r: 255, g: 240, b:220}; // warm yellow for late noon
        sunsetColor  = {r: 195, g: 120, b:80};
        earlyNightColor = {r: 40, g: 55, b:135}; // Deep purple for early night

        // Convert time strings to minutes
        function timeToMinutes(timeStr) {
            let [h, m] = timeStr.split(":").map(Number);
            return h * 60 + m;
        }

        // Initialize time values
        sunriseM = timeToMinutes(sunriseTimeStr);
        middayM  = timeToMinutes(middayTimeStr);
        lateNoonM = timeToMinutes(lateNoonTimeStr);
        sunsetM  = timeToMinutes(sunsetTimeStr);
        earlyNightM = timeToMinutes(earlyNightTimeStr);
        nightM   = timeToMinutes(nightTimeStr);

        // Exponential ease-in-out function
        function easeInOutExpo(t) {
            return (t < 0.5)
                ? 0.5 * Math.pow(2, 20 * t - 10)
                : 1 - 0.5 * Math.pow(2, -20 * t + 10);
        }

        // Map function (similar to p5.js map)
        function map(value, start1, stop1, start2, stop2) {
            return start2 + (stop2 - start2) * ((value - start1) / (stop1 - start1));
        }

        // Linear interpolation between colors
        function lerpColor(colorA, colorB, t) {
            return {
                r: Math.round(colorA.r + (colorB.r - colorA.r) * t),
                g: Math.round(colorA.g + (colorB.g - colorA.g) * t),
                b: Math.round(colorA.b + (colorB.b - colorA.b) * t)
            };
        }

        // Log phase changes
        function logPhaseChange(phase) {
            if (currentPhase !== phase) {
                currentPhase = phase;
                console.log(`Phase changed to: ${phase}`);
            }
        }

        // ---------------------------
        // Tint logic with Late Noon + Early Night (kept as-is)
        // ---------------------------
        function getTintForTime(minutes) {
          let phase;

          if (minutes >= sunriseM && minutes < middayM) {
            phase = "Sunrise → Midday";
            let t = map(minutes, sunriseM, middayM, 0, 1);
            t = easeInOutExpo(t, easeFactorSunriseMidday);
            logPhaseChange(phase);
            return lerpColor(sunriseColor, middayColor, t);

          } else if (minutes >= middayM && minutes < lateNoonM) {
            phase = "Midday → Late Noon";
            let t = map(minutes, middayM, lateNoonM, 0, 1);
            t = easeInOutExpo(t, easeFactorMiddayLateNoon);
            logPhaseChange(phase);
            return lerpColor(middayColor, lateNoonColor, t);

          } else if (minutes >= lateNoonM && minutes < sunsetM) {
            phase = "Late Noon → Sunset";
            let t = map(minutes, lateNoonM, sunsetM, 0, 1);
            t = easeInOutExpo(t, easeFactorLateNoonSunset);
            logPhaseChange(phase);
            return lerpColor(lateNoonColor, sunsetColor, t);

          } else if (minutes >= sunsetM && minutes < earlyNightM) {
            phase = "Sunset → Early Night";
            let t = map(minutes, sunsetM, earlyNightM, 0, 1);
            t = easeInOutExpo(t, easeFactorSunsetEarlyNight);
            logPhaseChange(phase);
            return lerpColor(sunsetColor, earlyNightColor, t);

          } else if (
            (earlyNightM < nightM && minutes >= earlyNightM && minutes < nightM) ||
            (earlyNightM > nightM && (minutes >= earlyNightM || minutes < nightM))
          ) {
            // Early Night → Night (handles wrap past midnight)
            phase = "Early Night → Night";
            let start = earlyNightM;
            let end = nightM > earlyNightM ? nightM : nightM + 1440;
            let m = (minutes < nightM && earlyNightM > nightM) ? minutes + 1440 : minutes;
            let t = map(m, start, end, 0, 1);
            t = easeInOutExpo(t, easeFactorEarlyNightNight);
            logPhaseChange(phase);
            return lerpColor(earlyNightColor, nightColor, t);

          } else {
            // Night → Sunrise (wraps)
            phase = "Night → Sunrise";
            let t = map(minutes, nightM, sunriseM, 0, 1);
            t = easeInOutExpo(t, easeFactorNightSunrise);
            logPhaseChange(phase);
            return lerpColor(nightColor, sunriseColor, t);
          }
        }

        // Convert minutes to HH:MM format
        function minutesToTime(minutes) {
            let h = Math.floor(minutes / 60) % 24;
            let m = minutes % 60;
            return `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}`;
        }

        const startTime = Date.now(); // when your program starts
        const timeofDawnChorus=5; //at 5 am dawn chorus starts
        const timeofMidday=12; //at 12 pm midday starts
        const timeofDuskChorus=18; //at 6 pm dusk chorus starts
        const timeofMidnight=0; //at 12 am dawn chorus starts

        let timeSegmentoftheDay=timeofMidnight;
        let nextTimeSegmentoftheDay=timeofDawnChorus;

        function millis() {
            return Date.now() - startTime; // ms since start
        }

        const nextTime=  (((millis() % totalLength) / totalLength)* 1440 )  + (60 * nextTimeSegmentoftheDay);

        /* ========= NEW: Clock (12 → 5 in 5 minutes) ========= */
        const clockCanvas = document.getElementById('clock');
        const clockCtx = clockCanvas.getContext('2d');

        const CLOCK_DURATION = 5 * 60 * 1000; // 5 minutes
        const CLOCK_START_ANGLE = -Math.PI / 2;                 // 12 o'clock
        const CLOCK_END_ANGLE   = CLOCK_START_ANGLE + 5 * (Math.PI / 6); // +5 hours
        let clockStartTs = null; // set on first frame

        // HiDPI crispness
        function fitForDPR(canvas, ctx) {
            const dpr = window.devicePixelRatio || 1;
            const cssW = canvas.clientWidth;
            const cssH = canvas.clientHeight;
            if (canvas.width !== cssW * dpr || canvas.height !== cssH * dpr) {
                canvas.width = cssW * dpr;
                canvas.height = cssH * dpr;
                ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
            }
        }

        function renderClock(angle) {
            fitForDPR(clockCanvas, clockCtx);
            const w = clockCanvas.clientWidth, h = clockCanvas.clientHeight;
            const cx = w / 2, cy = h / 2;
            const r = Math.min(w, h) * 0.45;

            clockCtx.clearRect(0, 0, w, h);

            // White face
            clockCtx.beginPath();
            clockCtx.arc(cx, cy, r, 0, Math.PI * 2);
            clockCtx.fillStyle = '#fff';
            clockCtx.fill();

            // Black hand
            clockCtx.beginPath();
            clockCtx.moveTo(cx, cy);
            clockCtx.lineTo(cx + r * 0.9 * Math.cos(angle), cy + r * 0.9 * Math.sin(angle));
            clockCtx.lineWidth = 3;
            clockCtx.lineCap = 'round';
            clockCtx.strokeStyle = '#000';
            clockCtx.stroke();

            // Black center pin
            clockCtx.beginPath();
            clockCtx.arc(cx, cy, 3, 0, Math.PI * 2);
            clockCtx.fillStyle = '#000';
            clockCtx.fill();
        }

        // Main animation loop (kept, with a timestamp param added)
        function animate(ts) {
            if (!clockStartTs) clockStartTs = ts;

            // --- Simulation logic (unchanged) ---
            let currentTime = millis();
            let cyclePosition = (currentTime % totalLength) / totalLength;
            let simulatedMinutes = cyclePosition * 1440; // 1440 minutes in a day

            // take into account the time segment start
            simulatedMinutes = simulatedMinutes + (60 * timeSegmentoftheDay);
            simulatedMinutes = simulatedMinutes % 1440;

            let tintColor;

            if (simulatedMinutes <= nextTime) {
                phase = "Next";
                tintColor = getTintForTime(simulatedMinutes);
            }

            // Apply tint
            let overlay = document.getElementById('tintOverlay');
            overlay.style.backgroundColor = `rgb(${tintColor.r}, ${tintColor.g}, ${tintColor.b})`;
            //overlay.style.background = `linear-gradient(rgba(255, 0, 0, 0) 2%, rgba(${tintColor.r}, ${tintColor.g}, ${tintColor.b}, 1) 10%)`;

            // --- NEW: Clock progress (12 → 5 over 5 minutes, then stop) ---
            const elapsedClock = ts - clockStartTs;
            const tClock = Math.min(elapsedClock / CLOCK_DURATION, 1); // 0..1
            const angle = CLOCK_START_ANGLE + tClock * (CLOCK_END_ANGLE - CLOCK_START_ANGLE);
            renderClock(angle);

            requestAnimationFrame(animate);
        }

        // Start the animation
        requestAnimationFrame(animate);

        /*
        // Add touch event listener for the hobject:// call (unchanged)
        document.addEventListener('touchstart', function(e) {
            location.href = 'hobject://do?when_done=hide';
        });

        // Keep the clock crisp on resize
        window.addEventListener('resize', () => fitForDPR(clockCanvas, clockCtx));
        */
        
    </script>
</body>
</html>
